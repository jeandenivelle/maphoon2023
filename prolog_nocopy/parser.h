

// Parser generated by Maphoon 2022.
// Written by Hans de Nivelle, March 2021-May 2022.
// See the licence that was included with the code. 

#ifndef PROLOG_PARSER_ 
#define PROLOG_PARSER_   1

#include <vector>
#include <iostream>
#include <unordered_set>
#include <unordered_map>

#include "symbol.h"

#line 51 "grammar.m"
 #include "tokenizer.h" 
 #include "../calculator/varstore.h" 
#line 18 "idee.x"
 

namespace prolog { 

  
class parser
{

   struct statesymbol
   {
      size_t state;
      prolog::symboltype type;

      statesymbol( size_t state, prolog::symboltype type )
         : state( state ), type( type )
      { }

      struct hash
      {
         size_t operator( ) ( const statesymbol& ) const;
      };

      struct equal_to
      {
         bool operator( ) ( const statesymbol &, const statesymbol& ) const;
      };

      template< typename D > using map =
      std::unordered_map< statesymbol, D, hash, equal_to > ;
   };


   struct expectation
   {
      using symboltypeset = std::unordered_set< prolog::symboltype > ;

      struct seenonstack
      {
         symboltypeset set;  
         size_t maxskip;

         seenonstack( const symboltypeset& set, size_t maxskip )
            : set( set ), maxskip( maxskip )
         { }

         seenonstack( symboltypeset&& set, size_t maxskip )
            : set( std::move( set )), maxskip( maxskip )
         { }
      };

      std::vector< seenonstack > trigger;
      std::string expected;
         // Explains what we expected after the trigger.
   };


   static const std::unordered_map< prolog::symboltype,
      std::pair< size_t, std::unordered_set< prolog::symboltype >>> 
   startsymbols;
      // Maps possible start symbols to pairs of
      // initial state, and terminator sets.

   static 
   const std::vector< std::pair< char, size_t >> reductioninfo; 
      // Indexed by the states.
      // char = 'T' : the state consists of a single reduction (trivial).
      // char = 'D' : the state has a default reduction, which will be
      //              carried out when lookahead has no shift.
      // char = 'N' : the state has no reductions.
      // char = 'H' : none of the above. The state is hard.

   static const statesymbol::map< size_t > shifts; 
   static const statesymbol::map< std::vector< size_t >> reductions;

   static const std::vector< expectation > errormessages;

   std::vector< size_t > statestack;
   std::vector< prolog::symbol > symbolstack;

   std::optional< prolog::symbol > lookahead;

   bool timetosaygoodbye = false; 
      // If you assign true, the parser will assume that 
      // it is really time to say goodbye. No more symbols will 
      // be read. 

public: 
   short unsigned int debug = 0;  
      // 0 : no output
      // 1 : only the parse stack
      // 2 : chosen shifts and reductions
      // 3 : attempted reductions. 

   short unsigned int checkattrtypes = 0;  
   short unsigned int checkmovable = 0;
      // 0 : we don't check.
      // 1 : we check and complain when wrong.
      // 2 : we check and stop when wrong.

   unsigned int timesincelasterror = 99999999;
   unsigned int maxrecovery = 100;
      // Maximal number of symbols that will be thrown away during
      // a recovery attempt.

   unsigned int maxtrialperiod = 3; 
      // If after a recovery attempt, a new error occurs within the
      // trial period, it will be assumed that the attempt failed, 
      // and no new error message will be generated. 
      // Parameters, defined by %parameters:

   tokenizer & tok;
   varstore<term> & vs;
   syntax & syntdefs;
   listconstr & list;


   parser( tokenizer & tok,
           varstore<term> & vs,
           syntax & syntdefs,
           listconstr & list )
      : tok( tok ),
        vs( vs ),
        syntdefs( syntdefs ),
        list( list )
   { }


   // i-th symbol on the symbolstack, looking backwards:
   // This means that 0 is undefined, 1 is .back( ), etc. 

   prolog::symbol& topsymbol( size_t i )
      { return *( symbolstack. end( ) - i ); }

   const prolog::symbol& topsymbol( size_t i ) const
      { return *( symbolstack. cend( ) - i ); }

   void resetlookahead( )
   {
      lookahead. reset( );
   }

   bool haslookahead( ) const 
   {
      return lookahead. has_value( );
   } 

   void ensurelookahead( ) 
   {
      if( !haslookahead( ))
         lookahead =  tok. get( syntdefs ); 
 
   }

   // Exists to give the user access to the lookahead:

   const prolog::symbol& getlookahead( ) const 
   {
      return lookahead. value( );
   }

public: 
   static prolog::symbol recover_symbol( );
      // Create symbol( __recover_ )   
   
   void reduce( prolog::symboltype lefttype, 
                prolog::symbol::attrtype&& attr, size_t rightsize );

   prolog::symbol parse( prolog::symboltype start );

   size_t match( const expectation& exp ) const; 
      // Try to match an expectation into the symbolstack.
      // If matching fails, return a number > symbolstack. size( ).

   void syntaxerror( );
      // When we encounter an error, the parser calls this function.
      // It should decide if the error is new 
      // (by checking timesincelasterror).
      // If it thinks that the error is new, it should set 
      // timesincelasterror = 0.

   void reset( );
      // Resets the parser. This is necessary when the parser is 
      // called repeatedly. 

   void print( std::ostream& out ) const;
      // Prints the state of the parser.

   // Declarations of reduction functions and their conditions:
   // They have no arguments because they use the stack.

   term body1( );
   term body2( );
   term body3( );
   term body4( );
   term body5( );
   term body6( );
   term body7( );
   term body8( );
   short cond9( ) const;
   term body9( );
   short cond10( ) const;
   term body10( );
   term body11( );
   term body12( );
   term body13( );
   std::vector<term> body14( );
   std::vector<term> body15( );
   short cond16( ) const;
   std::vector<term> body16( );
   short cond17( ) const;
   std::vector<term> body17( );
   term body18( );
   term body19( );
   short cond20( ) const;
   opdef body20( );
   short cond21( ) const;
   opdef body21( );
   short cond22( ) const;
   opdef body22( );


};

}


#endif

