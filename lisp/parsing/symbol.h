
// The code below was generated by Maphoon 2021.

// Definition of struct symbol:

#ifndef PARSING_SYMBOL_
#define PARSING_SYMBOL_    1

#include <iostream>
#include <variant>
#include <optional>
#include <stdexcept>

#line 15 "grammar.m"
 #include "../../filereader.h" 
 #include "../../../easycomp2022a/bigint.h" 
 #include <vector> 
 #include "interval.h" 
 #include "../list/list.h" 

namespace parsing { 

   enum symboltype
   {
      sym_Nil, sym_Inlist, sym__recover_, sym_QUOTE, 
      sym_ATOM, sym_CHAR, sym_Session, sym_EOF, 
      sym_LPAR, sym_SCANERROR, sym_FILEBAD, sym_WHITESPACE, 
      sym_INTEGER, sym_COMMENT, sym_RPAR, sym_EMPTY, 
      sym_S_expr, sym_FLOATING, sym_LBRACE, sym_STRING, 
      sym_RBRACE, sym_DOT
   };

   const char* getcstring( symboltype );

   inline std::ostream& operator << ( std::ostream& out, symboltype tp )
      { out << getcstring( tp );  return out; }

   struct symbol
   {
      using attrtype = std::variant < std::monostate, list::list > ;

      using infotype = interval;

      symboltype type;
      std::optional<infotype> info;
      attrtype attr;

      symbol( ) = delete;
      symbol( const symbol& ) = default;
      symbol( symbol&& ) noexcept = default;
      symbol& operator = ( const symbol& ) = default;
      symbol& operator = ( symbol&& ) noexcept = default;
      ~symbol( ) = default;

      symbol( symboltype type,
              const std::optional<infotype> & info )
       : type( type ),
         info( info )
      { }

      symbol( symboltype type,
              const std::optional<infotype> & info,
              attrtype && attr )
       : type( type ),
         info( info ),
         attr( std::move( attr ))
      { }

      symbol( symboltype type,
              const std::optional<infotype> & info,
              const list::list & attr )
       : type( type ),
         info( info ),
         attr( attr )
      { }

      symbol( symboltype type,
              const std::optional<infotype> & info,
              list::list && attr )
       : type( type ),
         info( info ),
         attr( std::move( attr ))
      { }


      void print( std::ostream& out ) const;

      bool has_right_attribute( ) const;

      template< typename T > T& get( )
         { return std::get<T> ( attr ); }
      
      template< typename T > const T& get( ) const &
         { return std::get<T> ( attr ); }
      
      template< typename T > const T& get( ) &&
         { return std::get<T> ( std::move( attr ) ); }
      
   };

   inline
   std::ostream& operator << ( std::ostream& out, const symbol& sym )
      { sym. print( out ); return out; }


}

#endif


