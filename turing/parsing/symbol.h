
// The code below was generated by Maphoon 2023.

// Definition of struct symbol:

#ifndef PARSING_SYMBOL_
#define PARSING_SYMBOL_    1

#include <iostream>
#include <variant>
#include <optional>
#include <concepts>
#include <stdexcept>

#line 35 "grammar.m"
 #include "../turingmachine.h" 
 #include "location.h" 
 #include <vector> 

namespace parsing { 

   enum symboltype
   {
      sym_OptNewLines, sym_NewLines, sym_TransitionMap, sym_STRING, 
      sym_COMMA, sym_ALPHABET, sym_Words, sym_NL, 
      sym_ARROW, sym_WHITESPACE, sym_BADFILE, sym_COMMENT, 
      sym_MachineWithInputs, sym_StateSet, sym_LeftRightStat, sym_Lhs, 
      sym_CHAR, sym_DOT, sym_EMPTY, sym_GARBAGE, 
      sym_EOF, sym_STARTING, sym_ACCEPTING, sym_BLANK, 
      sym_TRANSITIONS, sym_INPUTS, sym__recover_, sym_Transition, 
      sym_Rhs, sym_Word, sym_INTEGER, sym_OptInputs, 
      sym_State, sym_CharacterSet
   };

   const char* getcstring( symboltype );

   inline std::ostream& operator << ( std::ostream& out, symboltype tp )
      { out << getcstring( tp );  return out; }

   struct symbol
   {
      using attrtype = std::variant < std::monostate, std::set<char>, state, 
            rhs, std::pair<lhs, rhs>, int, std::set<state>, 
            char, std::pair<turingmachine, std::vector<std::string> >, std::vector<std::string>, lhs, 
            std::string, turingmachine::deltatype > ;

      using infotype = location;

      symboltype type;
      std::optional<infotype> info;
      attrtype attr;

      symbol( ) = delete;
      symbol( const symbol& ) = default;
      symbol( symbol&& ) noexcept = default;
      symbol& operator = ( const symbol& ) = default;
      symbol& operator = ( symbol&& ) noexcept = default;
      ~symbol( ) = default;

      symbol( symboltype type,
              const std::optional<infotype> & info )
       : type( type ),
         info( info )
      { }

      template< typename _T = attrtype > 
         requires std::copyable< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              const attrtype & attr )
       : type( type ),
         info( info ),
         attr( attr )
      { }

      template< typename _T = attrtype > 
         requires std::is_nothrow_move_constructible_v< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              attrtype && attr )
       : type( type ),
         info( info ),
         attr( std::move( attr ))
      { }

      template< typename _T = std::set<char> > 
         requires std::copyable< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              const std::set<char> & attr )
       : type( type ),
         info( info ),
         attr( attr )
      { }

      template< typename _T = std::set<char> > 
         requires std::is_nothrow_move_constructible_v< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              std::set<char> && attr )
       : type( type ),
         info( info ),
         attr( std::move( attr ))
      { }

      template< typename _T = state > 
         requires std::copyable< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              const state & attr )
       : type( type ),
         info( info ),
         attr( attr )
      { }

      template< typename _T = state > 
         requires std::is_nothrow_move_constructible_v< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              state && attr )
       : type( type ),
         info( info ),
         attr( std::move( attr ))
      { }

      template< typename _T = rhs > 
         requires std::copyable< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              const rhs & attr )
       : type( type ),
         info( info ),
         attr( attr )
      { }

      template< typename _T = rhs > 
         requires std::is_nothrow_move_constructible_v< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              rhs && attr )
       : type( type ),
         info( info ),
         attr( std::move( attr ))
      { }

      template< typename _T = std::pair<lhs, rhs> > 
         requires std::copyable< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              const std::pair<lhs, rhs> & attr )
       : type( type ),
         info( info ),
         attr( attr )
      { }

      template< typename _T = std::pair<lhs, rhs> > 
         requires std::is_nothrow_move_constructible_v< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              std::pair<lhs, rhs> && attr )
       : type( type ),
         info( info ),
         attr( std::move( attr ))
      { }

      template< typename _T = int > 
         requires std::is_nothrow_move_constructible_v< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              int attr )
       : type( type ),
         info( info ),
         attr( attr )
      { }

      template< typename _T = std::set<state> > 
         requires std::copyable< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              const std::set<state> & attr )
       : type( type ),
         info( info ),
         attr( attr )
      { }

      template< typename _T = std::set<state> > 
         requires std::is_nothrow_move_constructible_v< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              std::set<state> && attr )
       : type( type ),
         info( info ),
         attr( std::move( attr ))
      { }

      template< typename _T = char > 
         requires std::is_nothrow_move_constructible_v< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              char attr )
       : type( type ),
         info( info ),
         attr( attr )
      { }

      template< typename _T = std::pair<turingmachine, std::vector<std::string> > > 
         requires std::copyable< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              const std::pair<turingmachine, std::vector<std::string> > & attr )
       : type( type ),
         info( info ),
         attr( attr )
      { }

      template< typename _T = std::pair<turingmachine, std::vector<std::string> > > 
         requires std::is_nothrow_move_constructible_v< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              std::pair<turingmachine, std::vector<std::string> > && attr )
       : type( type ),
         info( info ),
         attr( std::move( attr ))
      { }

      template< typename _T = std::vector<std::string> > 
         requires std::copyable< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              const std::vector<std::string> & attr )
       : type( type ),
         info( info ),
         attr( attr )
      { }

      template< typename _T = std::vector<std::string> > 
         requires std::is_nothrow_move_constructible_v< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              std::vector<std::string> && attr )
       : type( type ),
         info( info ),
         attr( std::move( attr ))
      { }

      template< typename _T = lhs > 
         requires std::copyable< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              const lhs & attr )
       : type( type ),
         info( info ),
         attr( attr )
      { }

      template< typename _T = lhs > 
         requires std::is_nothrow_move_constructible_v< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              lhs && attr )
       : type( type ),
         info( info ),
         attr( std::move( attr ))
      { }

      template< typename _T = std::string > 
         requires std::copyable< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              const std::string & attr )
       : type( type ),
         info( info ),
         attr( attr )
      { }

      template< typename _T = std::string > 
         requires std::is_nothrow_move_constructible_v< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              std::string && attr )
       : type( type ),
         info( info ),
         attr( std::move( attr ))
      { }

      template< typename _T = turingmachine::deltatype > 
         requires std::copyable< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              const turingmachine::deltatype & attr )
       : type( type ),
         info( info ),
         attr( attr )
      { }

      template< typename _T = turingmachine::deltatype > 
         requires std::is_nothrow_move_constructible_v< _T > 
      symbol( symboltype type,
              const std::optional<infotype> & info,
              turingmachine::deltatype && attr )
       : type( type ),
         info( info ),
         attr( std::move( attr ))
      { }


      void print( std::ostream& out ) const;

      bool has_correct_attribute( ) const;

      template< typename T > T& get( )
         { return std::get<T> ( attr ); }
      
      template< typename T > const T& get( ) const
         { return std::get<T> ( attr ); }
      
   };

   inline
   std::ostream& operator << ( std::ostream& out, const symbol& sym )
      { sym. print( out ); return out; }


}

#endif


