

// Parser generated by Maphoon 2022.
// Written by Hans de Nivelle, March 2021-May 2022.
// See the licence that was included with the code. 

#ifndef PARSER_ 
#define PARSER_   1

#include <vector>
#include <iostream>
#include <unordered_set>
#include <unordered_map>

#include "symbol.h"

#line 44 "grammar.m"
 #include "varstore.h" 
 #include "tokenizer.h" 
 #include <cmath> 
#line 18 "idee.x"
 

  
class parser
{

   struct statesymbol
   {
      size_t state;
      symboltype type;

      statesymbol( size_t state, symboltype type )
         : state( state ), type( type )
      { }

      struct hash
      {
         size_t operator( ) ( const statesymbol& ) const;
      };

      struct equal_to
      {
         bool operator( ) ( const statesymbol &, const statesymbol& ) const;
      };

      template< typename D > using map =
      std::unordered_map< statesymbol, D, hash, equal_to > ;
   };


   struct expectation
   {
      using symboltypeset = std::unordered_set< symboltype > ;

      struct seenonstack
      {
         symboltypeset set;  
         size_t maxskip;

         seenonstack( const symboltypeset& set, size_t maxskip )
            : set( set ), maxskip( maxskip )
         { }

         seenonstack( symboltypeset&& set, size_t maxskip )
            : set( std::move( set )), maxskip( maxskip )
         { }
      };

      std::vector< seenonstack > trigger;
      std::string expected;
         // Explains what we expected after the trigger.
   };


   static const std::unordered_map< symboltype,
      std::pair< size_t, std::unordered_set< symboltype >>> 
   startsymbols;
      // Maps possible start symbols to pairs of
      // initial state, and terminator sets.

   static 
   const std::vector< std::pair< char, size_t >> reductioninfo; 
      // Indexed by the states.
      // char = 'T' : the state consists of a single reduction (trivial).
      // char = 'D' : the state has a default reduction, which will be
      //              carried out when lookahead has no shift.
      // char = 'N' : the state has no reductions.
      // char = 'H' : none of the above. The state is hard.

   static const statesymbol::map< size_t > shifts; 
   static const statesymbol::map< std::vector< size_t >> reductions;

   static const std::vector< expectation > errormessages;

   std::vector< size_t > statestack;
   std::vector< symbol > symbolstack;

   std::optional< symbol > lookahead;

   bool timetosaygoodbye = false; 
      // If you assign true, the parser will assume that 
      // it is really time to say goodbye. No more symbols will 
      // be read. 

public: 
   short unsigned int debug = 0;  
      // 0 : no output
      // 1 : only the parse stack
      // 2 : chosen shifts and reductions
      // 3 : attempted reductions. 

   short unsigned int checkattrtypes = 0;  
   short unsigned int checkmovable = 0;
      // 0 : we don't check.
      // 1 : we check and complain when wrong.
      // 2 : we check and stop when wrong.

   unsigned int timesincelasterror = 99999999;
   unsigned int maxrecovery = 100;
      // Maximal number of symbols that will be thrown away during
      // a recovery attempt.

   unsigned int maxtrialperiod = 3; 
      // If after a recovery attempt, a new error occurs within the
      // trial period, it will be assumed that the attempt failed, 
      // and no new error message will be generated. 
      // Parameters, defined by %parameters:

   varstore<double> & memory;
   std::vector<std::string> & errorlog;
   tokenizer & tok;


   parser( varstore<double> & memory,
           std::vector<std::string> & errorlog,
           tokenizer & tok )
      : memory( memory ),
        errorlog( errorlog ),
        tok( tok )
   { }


   // i-th symbol on the symbolstack, looking backwards:
   // This means that 0 is undefined, 1 is .back( ), etc. 

   symbol& topsymbol( size_t i )
      { return *( symbolstack. end( ) - i ); }

   const symbol& topsymbol( size_t i ) const
      { return *( symbolstack. cend( ) - i ); }

   void resetlookahead( )
   {
      lookahead. reset( );
   }

   bool haslookahead( ) const 
   {
      return lookahead. has_value( );
   } 

   void ensurelookahead( ) 
   {
      if( !haslookahead( ))
         lookahead =  tok. read( ); 
 
   }

   // Exists to give the user access to the lookahead:

   const symbol& getlookahead( ) const 
   {
      return lookahead. value( );
   }

public: 
   static symbol recover_symbol( );
      // Create symbol( __recover_ )   
   
   void reduce( symboltype lefttype, 
                symbol::attrtype&& attr, size_t rightsize );

   symbol parse( symboltype start );

   size_t match( const expectation& exp ) const; 
      // Try to match an expectation into the symbolstack.
      // If matching fails, return a number > symbolstack. size( ).

   void syntaxerror( );
      // When we encounter an error, the parser calls this function.
      // It should decide if the error is new 
      // (by checking timesincelasterror).
      // If it thinks that the error is new, it should set 
      // timesincelasterror = 0.

   void reset( );
      // Resets the parser. This is necessary when the parser is 
      // called repeatedly. 

   void print( std::ostream& out ) const;
      // Prints the state of the parser.

   // Declarations of reduction functions and their conditions:
   // They have no arguments because they use the stack.

   void body2( );
   void body3( );
   void body4( );
   void body5( );
   void body6( );
   void body7( );
   void body8( );
   double body9( );
   double body10( );
   double body11( );
   double body12( );
   double body13( );
   double body14( );
   double body15( );
   double body16( );
   double body17( );
   double body18( );
   double body19( );
   double body20( );
   double body21( );
   double body22( );
   double body23( );
   std::vector<double> body24( );
   std::vector<double> body25( );
   short cond26( ) const;
   short cond27( ) const;
   short cond28( ) const;
   short cond29( ) const;


};



#endif

