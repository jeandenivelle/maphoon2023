

// Parser generated by Maphoon 2021.
// Written by Hans de Nivelle, March 2021.
// See the licence that was included with the code. 

#ifndef PARSER 
#define PARSER   1

#include <vector>
#include <iostream>
#include <unordered_set>
#include <unordered_map>

#include "symbol.h"
#include "tokenizing.h"

#line 19 "idee.x"
 

struct parser
{

   struct statesymbol
   {
      size_t state;
      symboltype type;

      statesymbol( size_t state, symboltype type )
         : state( state ), type( type )
      { }

      struct hash
      {
         size_t operator( ) ( const statesymbol& ) const;
      };

      struct equal_to
      {
         bool operator( ) ( const statesymbol &, const statesymbol& ) const;
      };
   };

   struct decision
   {
      size_t push;  // If < parsetable. size( ), there is a push.
      size_t begin; // Indices into redtable.
      size_t end;

      decision( size_t push, size_t begin, size_t end )
         : push( push ),
           begin( begin ),
           end( end )
      { }
   };

   static std::unordered_map< symboltype,
      std::pair< size_t, std::unordered_set< symboltype >>> startsymbols;
      // Maps possible start symbols to pairs of
      // initial state, and terminator sets.

    static 
    std::unordered_map< size_t, std::pair< size_t, bool >> defaultreductions;
      // Maps state -> defaultred,bool.
      // If present, the state has a default reduction.
      // If the boolean is also true, the state contains only a reduction, 
      // which can be carried out without lookahead.

   static std::unordered_map< statesymbol, decision,
                    statesymbol::hash, statesymbol::equal_to > decisiontable;

   static std::vector< size_t > redtable;
      // Table of reductions.

   static
   std::unordered_map< symboltype, std::pair< symboltype, size_t >> rule_info;
      // Perhaps this should be a vector or an array.
      // If one wishes to index on symboltype, one needs to specify
      // the numbers in the declaration.

   std::vector< size_t > statestack;
   std::vector< symbol > symbolstack;
   std::optional< symbol > lookahead;

   unsigned int errorcount;
   std::optional< symbol > stop;
      // If you assign something here, the parser will stop
      // and return the stored value.
      // No more tokens will be read.

   unsigned int debug;

   // Parameters, defined by %parameters:



   bool cond( size_t rulenr ) const;
   symbol::attrtype body( size_t rulenr );
      // conditions and bodies of reductions.

   parser(  )
      : errorcount(0),
        debug(0)
   { }


   symbol parse( symboltype start );

   void print( std::ostream& out ) const;
      // Prints the state of the parser.



};

#endif

