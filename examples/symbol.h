
// The code below was generated by Maphoon 2021.

// Definition of struct symbol:

#ifndef SYMBOL
#define SYMBOL    1

#include <iostream>
#include <variant>
#include <optional>
#include <stdexcept>

enum symboltype
{
   sym_EOF, sym__recover, sym_Function, sym_Arglist, 
   sym_NUMBER, sym_Stat, sym_Expr, sym_E, 
   sym_Infix, sym_Do, sym_Postfix, sym_If, 
   sym_IDENTIFIER, sym_Prefix, sym_While, sym_RPAR, 
   sym_Then, sym_Else, sym_LPAR, sym_COMMA, 
   sym_BECOMES
};

std::ostream& operator << ( std::ostream& , symboltype );

struct symbol
{
   using attrtype = std::variant < std::monostate, opcode, ast, 
         long double, std::string, std::vector<ast>, const function* > ;

   symboltype type;
   attrtype attr;

   symbol( const symbol& ) = default;
   symbol( symbol&& ) = default;
   symbol& operator = ( const symbol& ) = default;
   symbol& operator = ( symbol&& ) = default;
   ~symbol( ) = default;

   symbol( symboltype type )
    : type( type )
   { }

   symbol( symboltype type,
           const opcode & attr )
    : type( type ),
      attr( attr )
   { }

   symbol( symboltype type,
           opcode && attr )
    : type( type ),
      attr( std::move( attr ))
   { }

   symbol( symboltype type,
           const ast & attr )
    : type( type ),
      attr( attr )
   { }

   symbol( symboltype type,
           ast && attr )
    : type( type ),
      attr( std::move( attr ))
   { }

   symbol( symboltype type,
           long double attr )
    : type( type ),
      attr( attr )
   { }

   symbol( symboltype type,
           const std::string & attr )
    : type( type ),
      attr( attr )
   { }

   symbol( symboltype type,
           std::string && attr )
    : type( type ),
      attr( std::move( attr ))
   { }

   symbol( symboltype type,
           const std::vector<ast> & attr )
    : type( type ),
      attr( attr )
   { }

   symbol( symboltype type,
           std::vector<ast> && attr )
    : type( type ),
      attr( std::move( attr ))
   { }

   symbol( symboltype type,
           const function* attr )
    : type( type ),
      attr( attr )
   { }


   void print( std::ostream& out ) const;

   bool iswellformed( ) const;
      // Check if the attribute type fits to 
      // symboltype. 
};

inline
std::ostream& operator << ( std::ostream& out, const symbol& sym )
   { sym. print( out ); return out; }


#endif


