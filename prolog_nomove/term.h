
// This code was automatically generated by treebuilder

#ifndef PROLOG_TERM_
#define PROLOG_TERM_   1

#include <iostream>
#include <utility>
#include <tuple>
#include <initializer_list>
#include "selector.h"

#include "/home/nivelle/programs/settheory2023/tvm/optional.h"
#include "/home/nivelle/programs/settheory2023/tvm/unit.h"
#include "/home/nivelle/programs/settheory2023/tvm/field.h"
#include "/home/nivelle/programs/settheory2023/tvm/local.h"
#include "/home/nivelle/programs/settheory2023/tvm/very_equal.h"
#include "/home/nivelle/programs/settheory2023/util/normalized.h"
#include "bigint.h"
#include "function.h"


namespace prolog { 


   class term{
   public:
      selector ssss;

      using loc00 = util::normalized<std::string>;
      using scal00 = tvm::unit;
      using rep00 = tvm::unit;
      using loc01 = tvm::unit;
      using scal01 = bigint;
      using rep01 = tvm::unit;
      using loc02 = double;
      using scal02 = tvm::unit;
      using rep02 = tvm::unit;
      using loc03 = tvm::unit;
      using scal03 = function;
      using rep03 = term;
      using loc04 = int;
      using scal04 = tvm::unit;
      using rep04 = tvm::unit;
      using loc05 = std::string;
      using scal05 = tvm::unit;
      using rep05 = tvm::unit;

      static constexpr bool check = true;

      union options
      {
         tvm::field< loc00, scal00, rep00 > fld00;
         tvm::field< loc01, scal01, rep01 > fld01;
         tvm::field< loc02, scal02, rep02 > fld02;
         tvm::field< loc03, scal03, rep03 > fld03;
         tvm::field< loc04, scal04, rep04 > fld04;
         tvm::field< loc05, scal05, rep05 > fld05;

         options( ) : fld02( ) { }
         ~options( ) noexcept { }
      };

   private:
      options repr;

   public:
      term( ) = delete;
      term( const term& );
      // term( term&& ) = delete; 
      const term& operator = ( const term& );
      // const term& operator = ( term&& ) = delete;
      ~term( ) noexcept;
      
      selector sel( ) const { return ssss; }
      bool very_equal_to( const term& ) const;
      void printstate( std::ostream& out ) const;
      
      term( selector sel, const util::normalized<std::string> & xx00 )
         : ssss( sel )
      {
         if( check && sel != sel_atom )
            throw std::invalid_argument( "wrong selector for constructor" );
         tvm::init( repr. fld00. loc, xx00 );
      }

      term( selector sel, const bigint & xx00 )
         : ssss( sel )
      {
         if( check && sel != sel_bigint )
            throw std::invalid_argument( "wrong selector for constructor" );
         repr. fld01. heap = takeshare( tvm::constr_scalar< scal01 > ( xx00 ));
      }

      term( selector sel, const double & xx00 )
         : ssss( sel )
      {
         if( check && sel != sel_double )
            throw std::invalid_argument( "wrong selector for constructor" );
         tvm::init( repr. fld02. loc, xx00 );
      }

      template< tvm::const_iterator< rep03 > It >
      term( selector sel, const function & xx00, It begin, It end )
         : ssss( sel )
      {
         if( check && sel != sel_functional )
            throw std::invalid_argument( "wrong selector for constructor" );
         repr. fld03. heap = takeshare( tvm::constr_scalar_repeated< scal03, rep03 > ( xx00, begin, end ));
      }

      term( selector sel, const function & xx00, std::initializer_list< rep03 > repeated )
         : term( sel, xx00, repeated. begin( ), repeated. end( ))
      { }

      term( selector sel, const int & xx00 )
         : ssss( sel )
      {
         if( check && sel != sel_int )
            throw std::invalid_argument( "wrong selector for constructor" );
         tvm::init( repr. fld04. loc, xx00 );
      }

      term( selector sel, const std::string & xx00 )
         : ssss( sel )
      {
         if( check && sel != sel_var && sel != sel_string )
            throw std::invalid_argument( "wrong selector for constructor" );
         tvm::init( repr. fld05. loc, xx00 );
      }

      struct const_atom
      {
         const term* xxxx;
         const term & operator * ( ) const { return * xxxx; }
         const_atom( const term* xxxx ) : xxxx( xxxx ) { }

         const util::normalized<std::string> & name( ) const { return xxxx -> repr. fld00. loc; }
      };
      const_atom view_atom( ) const {
         if( check && ssss != sel_atom )
            throw std::invalid_argument( "wrong selector for constructor" );
         return this;
      }

      struct mut_atom
      {
         term* xxxx;
         mut_atom( term* xxxx ) : xxxx( xxxx ) { }
         const term & operator * ( ) const { return * xxxx; }

         util::normalized<std::string> & name( ) { return xxxx -> repr. fld00. loc; }
         util::normalized<std::string> extr_name( ) { return std::move( xxxx -> repr. fld00. loc ); }
         void update_name( const util::normalized<std::string> & from ) { xxxx -> repr. fld00. loc = from; }
      };
      mut_atom view_atom( ) {
         if( check && ssss != sel_atom )
            throw std::invalid_argument( "wrong selector for constructor" );
         return this;
      }
      
      struct const_bigint
      {
         const term* xxxx;
         const term & operator * ( ) const { return * xxxx; }
         const_bigint( const term* xxxx ) : xxxx( xxxx ) { }

         const bigint & i( ) const { return xxxx -> repr. fld01. heap -> scal; }
      };
      const_bigint view_bigint( ) const {
         if( check && ssss != sel_bigint )
            throw std::invalid_argument( "wrong selector for constructor" );
         return this;
      }

      struct mut_bigint
      {
         term* xxxx;
         mut_bigint( term* xxxx ) : xxxx( xxxx ) { }
         const term & operator * ( ) const { return * xxxx; }

         const bigint & i( ) const { return xxxx -> repr. fld01. heap -> scal; }
         bigint extr_i( ) {
            if( iswritable( xxxx -> repr. fld01. heap ))
               return std::move( xxxx -> repr. fld01. heap -> scal );
            else
               return xxxx -> repr. fld01. heap -> scal;
         }
         void update_i( const bigint & repl )
         {
            if( !tvm::very_equal( xxxx -> repr. fld01. heap -> scal, repl ))
            {
               xxxx -> repr. fld01. heap = takeshare( makewritable( xxxx -> repr. fld01. heap ));
               xxxx -> repr. fld01. heap -> scal = repl;
            }
         }
      };
      mut_bigint view_bigint( ) {
         if( check && ssss != sel_bigint )
            throw std::invalid_argument( "wrong selector for constructor" );
         return this;
      }
      
      struct const_double
      {
         const term* xxxx;
         const term & operator * ( ) const { return * xxxx; }
         const_double( const term* xxxx ) : xxxx( xxxx ) { }

         const double & d( ) const { return xxxx -> repr. fld02. loc; }
      };
      const_double view_double( ) const {
         if( check && ssss != sel_double )
            throw std::invalid_argument( "wrong selector for constructor" );
         return this;
      }

      struct mut_double
      {
         term* xxxx;
         mut_double( term* xxxx ) : xxxx( xxxx ) { }
         const term & operator * ( ) const { return * xxxx; }

         double & d( ) { return xxxx -> repr. fld02. loc; }
         double extr_d( ) { return std::move( xxxx -> repr. fld02. loc ); }
         void update_d( const double & from ) { xxxx -> repr. fld02. loc = from; }
      };
      mut_double view_double( ) {
         if( check && ssss != sel_double )
            throw std::invalid_argument( "wrong selector for constructor" );
         return this;
      }
      
      struct const_func
      {
         const term* xxxx;
         const term & operator * ( ) const { return * xxxx; }
         const_func( const term* xxxx ) : xxxx( xxxx ) { }

         const function & f( ) const { return xxxx -> repr. fld03. heap -> scal; }
         size_t size( ) const { return xxxx -> repr. fld03. heap -> size( ); }
         const term & sub( size_t iiii ) const
            { return xxxx -> repr. fld03. heap -> begin( ) [ iiii ]; }
      };
      const_func view_func( ) const {
         if( check && ssss != sel_functional )
            throw std::invalid_argument( "wrong selector for constructor" );
         return this;
      }

      struct mut_func
      {
         term* xxxx;
         mut_func( term* xxxx ) : xxxx( xxxx ) { }
         const term & operator * ( ) const { return * xxxx; }

         const function & f( ) const { return xxxx -> repr. fld03. heap -> scal; }
         function extr_f( ) {
            if( iswritable( xxxx -> repr. fld03. heap ))
               return std::move( xxxx -> repr. fld03. heap -> scal );
            else
               return xxxx -> repr. fld03. heap -> scal;
         }
         void update_f( const function & repl )
         {
            if( !tvm::very_equal( xxxx -> repr. fld03. heap -> scal, repl ))
            {
               xxxx -> repr. fld03. heap = takeshare( makewritable( xxxx -> repr. fld03. heap ));
               xxxx -> repr. fld03. heap -> scal = repl;
            }
         }

         size_t size( ) const { return xxxx -> repr. fld03. heap -> size( ); }
         void push_back( const term & xx00)
         {
            xxxx -> repr. fld03. heap = tvm::push_back( xxxx -> repr. fld03. heap, xx00 );
         }
         void pop_back( ) { xxxx -> repr. fld03. heap = tvm::pop_back( xxxx -> repr. fld03. heap ); }
         const term& sub( size_t iiii ) const
            { return xxxx -> repr. fld03. heap -> begin( ) [ iiii ]; }
         void update_sub( size_t iiii, const term & repl )
         {
            if( !tvm::very_equal( xxxx -> repr. fld03. heap -> begin( ) [ iiii ], repl ))
            {
               xxxx -> repr. fld03. heap = takeshare( makewritable( xxxx -> repr. fld03. heap ));
               xxxx -> repr. fld03. heap -> begin( ) [ iiii ] = repl;
            }
         }
         
      };
      mut_func view_func( ) {
         if( check && ssss != sel_functional )
            throw std::invalid_argument( "wrong selector for constructor" );
         return this;
      }
      
      struct const_int
      {
         const term* xxxx;
         const term & operator * ( ) const { return * xxxx; }
         const_int( const term* xxxx ) : xxxx( xxxx ) { }

         const int & i( ) const { return xxxx -> repr. fld04. loc; }
      };
      const_int view_int( ) const {
         if( check && ssss != sel_int )
            throw std::invalid_argument( "wrong selector for constructor" );
         return this;
      }

      struct mut_int
      {
         term* xxxx;
         mut_int( term* xxxx ) : xxxx( xxxx ) { }
         const term & operator * ( ) const { return * xxxx; }

         int & i( ) { return xxxx -> repr. fld04. loc; }
         int extr_i( ) { return std::move( xxxx -> repr. fld04. loc ); }
         void update_i( const int & from ) { xxxx -> repr. fld04. loc = from; }
      };
      mut_int view_int( ) {
         if( check && ssss != sel_int )
            throw std::invalid_argument( "wrong selector for constructor" );
         return this;
      }
      
      struct const_string
      {
         const term* xxxx;
         const term & operator * ( ) const { return * xxxx; }
         const_string( const term* xxxx ) : xxxx( xxxx ) { }

         const std::string & s( ) const { return xxxx -> repr. fld05. loc; }
      };
      const_string view_string( ) const {
         if( check && ssss != sel_string )
            throw std::invalid_argument( "wrong selector for constructor" );
         return this;
      }

      struct mut_string
      {
         term* xxxx;
         mut_string( term* xxxx ) : xxxx( xxxx ) { }
         const term & operator * ( ) const { return * xxxx; }

         std::string & s( ) { return xxxx -> repr. fld05. loc; }
         std::string extr_s( ) { return std::move( xxxx -> repr. fld05. loc ); }
         void update_s( const std::string & from ) { xxxx -> repr. fld05. loc = from; }
      };
      mut_string view_string( ) {
         if( check && ssss != sel_string )
            throw std::invalid_argument( "wrong selector for constructor" );
         return this;
      }
      
      struct const_var
      {
         const term* xxxx;
         const term & operator * ( ) const { return * xxxx; }
         const_var( const term* xxxx ) : xxxx( xxxx ) { }

         const std::string & v( ) const { return xxxx -> repr. fld05. loc; }
      };
      const_var view_var( ) const {
         if( check && ssss != sel_var )
            throw std::invalid_argument( "wrong selector for constructor" );
         return this;
      }

      struct mut_var
      {
         term* xxxx;
         mut_var( term* xxxx ) : xxxx( xxxx ) { }
         const term & operator * ( ) const { return * xxxx; }

         std::string & v( ) { return xxxx -> repr. fld05. loc; }
         std::string extr_v( ) { return std::move( xxxx -> repr. fld05. loc ); }
         void update_v( const std::string & from ) { xxxx -> repr. fld05. loc = from; }
      };
      mut_var view_var( ) {
         if( check && ssss != sel_var )
            throw std::invalid_argument( "wrong selector for constructor" );
         return this;
      }
      
   };
}

#endif

